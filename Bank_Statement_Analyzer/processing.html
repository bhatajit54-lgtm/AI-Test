<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing - Bank Statement Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .container {
            background: white;
            border-radius: 20px;
            padding: 60px 40px;
            max-width: 600px;
            width: 100%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 { color: #667eea; margin-bottom: 20px; font-size: 28px; }
        .spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid #667eea;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            animation: spin 1s linear infinite;
            margin: 30px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .status { color: #666; font-size: 18px; margin: 20px 0; min-height: 50px; }
        .progress-bar {
            width: 100%;
            height: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            overflow: hidden;
            margin: 30px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.5s;
        }
        .error {
            color: #ef4444;
            padding: 20px;
            background: #fee;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
        }
        .btn-back {
            margin-top: 20px;
            padding: 12px 30px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            display: none;
        }
        .btn-back:hover { background: #764ba2; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Processing Your Statement</h1>
        <div class="spinner" id="spinner"></div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
        <div class="status" id="status">Initializing...</div>
        <div class="error" id="error"></div>
        <button class="btn-back" id="btn-back" onclick="goBack()">Go Back</button>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        function updateStatus(message, progress) {
            document.getElementById('status').textContent = message;
            document.getElementById('progress').style.width = progress + '%';
        }

        function showError(message) {
            document.getElementById('spinner').style.display = 'none';
            document.getElementById('error').textContent = message;
            document.getElementById('error').style.display = 'block';
            document.getElementById('btn-back').style.display = 'inline-block';
        }

        function goBack() {
            window.location.href = 'upload.html';
        }

        async function processPDF() {
            try {
                const pdfData = localStorage.getItem('bank_pdffile');
                if (!pdfData) {
                    showError('No PDF file found');
                    return;
                }

                updateStatus('Loading PDF...', 5);
                const pdf = await pdfjsLib.getDocument(pdfData).promise;

                updateStatus(`Extracting from ${pdf.numPages} pages...`, 10);

                let fullText = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n';
                    updateStatus(`Page ${i}/${pdf.numPages}...`, 10 + (i/pdf.numPages * 35));
                }

                updateStatus('Parsing transactions...', 50);
                const result = parseAxisBankStatement(fullText);

                console.log(`Found ${result.transactions.length} transactions`);

                updateStatus('Categorizing...', 75);
                result.transactions.forEach(txn => {
                    txn.category = categorizeTransaction(txn.description);
                });

                updateStatus('Saving...', 90);
                const summary = calculateSummary(result.transactions, result.openingBalance);

                localStorage.setItem('bank_transactions', JSON.stringify(result.transactions));
                localStorage.setItem('bank_accountinfo', JSON.stringify(result.accountInfo));
                localStorage.setItem('bank_summary', JSON.stringify(summary));

                updateStatus('Complete!', 100);

                setTimeout(() => window.location.href = 'analyze.html', 1000);

            } catch (error) {
                console.error(error);
                showError('Error: ' + error.message);
            }
        }

        function parseAxisBankStatement(text) {
            const transactions = [];
            let accountInfo = {};
            let openingBalance = 0;
            let prevBalance = 0;

            // Extract account info
            const accMatch = text.match(/Account No[:\s]*([\d]{15,18})/i);
            if (accMatch) accountInfo.accountNumber = accMatch[1];

            const ifscMatch = text.match(/IFSC Code[:\s]*([A-Z]{4}\d{7})/i);
            if (ifscMatch) accountInfo.ifsc = ifscMatch[1];

            const periodMatch = text.match(/From[:\s]*(\d{2}[\-\/]\d{2}[\-\/]\d{4})\s+To[:\s]*(\d{2}[\-\/]\d{2}[\-\/]\d{4})/i);
            if (periodMatch) accountInfo.period = `${periodMatch[1]} to ${periodMatch[2]}`;

            const nameMatch = text.match(/^([A-Z][A-Z\s]{5,30})(?=\s*Joint|\s*NO\s)/m);
            if (nameMatch) accountInfo.name = nameMatch[1].trim();

            // Find opening balance - it's the number right after "OPENING BALANCE" text
            const openMatch = text.match(/OPENING BALANCE[\s\S]*?(\d+\.\d{2})/i);
            if (openMatch) {
                openingBalance = parseFloat(openMatch[1]);
                prevBalance = openingBalance;
            }

            // Parse all transactions
            // Pattern: DD-MM-YYYY followed by text then amounts and balance
            const dateRegex = /(\d{2}-\d{2}-\d{4})/g;
            let match;

            while ((match = dateRegex.exec(text)) !== null) {
                const date = match[1];
                const startPos = match.index + date.length;

                // Get next 500 characters after the date
                const chunk = text.substring(startPos, startPos + 500);

                // Find the next date or end
                const nextDateMatch = chunk.match(/\d{2}-\d{2}-\d{4}/);
                const chunkEnd = nextDateMatch ? nextDateMatch.index : chunk.length;
                const txnText = chunk.substring(0, chunkEnd);

                // Extract all decimal numbers (amounts)
                const amounts = txnText.match(/\b\d+\.\d{2}\b/g);

                if (!amounts || amounts.length === 0) continue;

                // Last number is always the balance
                const balance = parseFloat(amounts[amounts.length - 1]);

                // Skip if balance didn't change
                if (balance === prevBalance) continue;

                // Calculate amount and type
                const balanceChange = balance - prevBalance;
                const amount = Math.abs(balanceChange);
                const type = balanceChange > 0 ? 'Credit' : 'Debit';

                // Extract description - remove dates and amounts
                let description = txnText
                    .replace(/\d{2}-\d{2}-\d{4}/g, '')
                    .replace(/\b\d+\.\d{2}\b/g, '')
                    .replace(/\s{2,}/g, ' ')
                    .replace(/^[\s\d]+/, '')
                    .trim()
                    .substring(0, 150);

                if (description && amount >= 0.01) {
                    transactions.push({
                        date: date,
                        description: description,
                        type: type,
                        amount: amount,
                        balance: balance,
                        category: ''
                    });

                    prevBalance = balance;
                }
            }

            return {
                accountInfo: accountInfo,
                transactions: transactions,
                openingBalance: openingBalance
            };
        }

        function categorizeTransaction(description) {
            const desc = description.toUpperCase();

            if (desc.includes('INT.PD') || desc.includes('INTEREST')) return 'Interest Income';
            if (desc.includes('SWIGGY') || desc.includes('ZOMATO') || desc.includes('HUNGERBOX') || 
                desc.includes('MDP COFFEE')) return 'Food & Dining';
            if (desc.includes('FLIPKART') || desc.includes('AMAZON') || desc.includes('MEESHO')) return 'Shopping';
            if (desc.includes('UBER') || desc.includes('IRCTC') || desc.includes('BUS')) return 'Transportation';
            if (desc.includes('HOSPITAL') || desc.includes('PHARMACY') || desc.includes('V CARE')) return 'Healthcare';
            if (desc.includes('WIPRO') || desc.includes('SALARY')) return 'Salary/Income';
            if (desc.includes('PPF') || desc.includes('IPPF') || desc.includes('MONEYLICIOUS') || desc.includes('DHAN')) return 'Investments';
            if (desc.includes('UPI/P2M') || desc.includes('UPI/P2A') || desc.includes('BHARATPE')) return 'UPI Payments';
            if (desc.includes('NEFT') || desc.includes('IMPS') || desc.includes('RTGS')) return 'Bank Transfers';
            if (desc.includes('ZEPTO') || desc.includes('BIGBASKET')) return 'Groceries';
            if (desc.includes('BOOKMYSHOW')) return 'Entertainment';
            if (desc.includes('AIRTEL') || desc.includes('JIO')) return 'Utilities';
            if (desc.includes('MAB') || desc.includes('CHARGE') || desc.includes('GST')) return 'Bank Charges';
            if (desc.includes('ACH-CR') || desc.includes('DIVIDEND') || desc.includes('VEDANTA') || desc.includes('HPCL')) return 'Dividend Income';
            if (desc.includes('AC XFR')) return 'Internal Transfer';

            return 'Others';
        }

        function calculateSummary(transactions, openingBalance) {
            let totalCredits = 0;
            let totalDebits = 0;

            transactions.forEach(txn => {
                if (txn.type === 'Credit') {
                    totalCredits += txn.amount;
                } else {
                    totalDebits += txn.amount;
                }
            });

            const closingBalance = transactions.length > 0 ? 
                transactions[transactions.length - 1].balance : openingBalance;

            return {
                openingBalance: openingBalance,
                closingBalance: closingBalance,
                totalCredits: totalCredits,
                totalDebits: totalDebits,
                netChange: closingBalance - openingBalance,
                transactionCount: transactions.length
            };
        }

        window.onload = function() {
            processPDF();
        };
    </script>
</body>
</html>
