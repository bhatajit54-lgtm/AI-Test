<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing - Bank Statement Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .container {
            background: white;
            border-radius: 20px;
            padding: 60px 40px;
            max-width: 600px;
            width: 100%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 { color: #667eea; margin-bottom: 20px; font-size: 28px; }
        .spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid #667eea;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            animation: spin 1s linear infinite;
            margin: 30px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .status { color: #666; font-size: 18px; margin: 20px 0; min-height: 50px; }
        .progress-bar {
            width: 100%;
            height: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            overflow: hidden;
            margin: 30px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.5s;
        }
        .error {
            color: #ef4444;
            padding: 20px;
            background: #fee;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
        }
        .btn-back {
            margin-top: 20px;
            padding: 12px 30px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            display: none;
        }
        .btn-back:hover { background: #764ba2; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Processing Your Statement</h1>
        <div class="spinner" id="spinner"></div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
        <div class="status" id="status">Initializing...</div>
        <div class="error" id="error"></div>
        <button class="btn-back" id="btn-back" onclick="goBack()">Go Back</button>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        function updateStatus(message, progress) {
            document.getElementById('status').textContent = message;
            document.getElementById('progress').style.width = progress + '%';
        }

        function showError(message) {
            document.getElementById('spinner').style.display = 'none';
            document.getElementById('error').textContent = message;
            document.getElementById('error').style.display = 'block';
            document.getElementById('btn-back').style.display = 'inline-block';
        }

        function goBack() {
            window.location.href = 'upload.html';
        }

        async function processPDF() {
            try {
                const pdfData = localStorage.getItem('bank_pdffile');
                if (!pdfData) {
                    showError('No PDF file found');
                    return;
                }

                updateStatus('Loading PDF...', 5);
                const pdf = await pdfjsLib.getDocument(pdfData).promise;
                
                updateStatus(`Extracting from ${pdf.numPages} pages...`, 10);
                
                let fullText = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\\n';
                    updateStatus(`Page ${i}/${pdf.numPages}...`, 10 + (i/pdf.numPages * 35));
                }

                updateStatus('Parsing transactions...', 50);
                const result = processBankStatement(fullText);
                
                console.log(`Found ${result.transactions.length} transactions`);
                
                updateStatus('Categorizing...', 75);
                result.transactions.forEach(txn => {
                    txn.category = categorizeTransaction(txn.description);
                });

                updateStatus('Saving...', 90);
                const summary = calculateSummary(result.transactions, result.openingBalance);
                
                localStorage.setItem('bank_transactions', JSON.stringify(result.transactions));
                localStorage.setItem('bank_accountinfo', JSON.stringify(result.accountInfo));
                localStorage.setItem('bank_summary', JSON.stringify(summary));

                updateStatus('Complete!', 100);
                
                setTimeout(() => window.location.href = 'analyze.html', 1000);

            } catch (error) {
                console.error(error);
                showError('Error: ' + error.message);
            }
        }

        
        // ============================================
        // MULTI-BANK STATEMENT PARSER
        // Supports: Axis Bank, HDFC Bank, ICICI Bank
        // ============================================

        // Bank Detection Function
        function detectBank(text) {
            const upperText = text.toUpperCase();

            if (upperText.includes('HDFC BANK LIMITED') || upperText.includes('HDFC BANK')) {
                return 'HDFC';
            } else if (upperText.includes('ICICI BANK') || 
                       (upperText.includes('STATEMENT OF ACCOUNT NO') && upperText.includes('UTIB'))) {
                return 'ICICI';
            } else if (upperText.includes('AXIS BANK')) {
                return 'Axis';
            }

            return 'Unknown';
        }

        // Main Processing Function - Routes to appropriate parser
        function processBankStatement(text) {
            const bankType = detectBank(text);
            console.log(`Detected bank: ${bankType}`);

            let result;
            switch(bankType) {
                case 'Axis':
                    result = parseAxisBankStatement(text);
                    break;
                case 'HDFC':
                    result = parseHDFCBankStatement(text);
                    break;
                case 'ICICI':
                    result = parseICICIBankStatement(text);
                    break;
                default:
                    throw new Error('Bank format not supported. Currently supports Axis, HDFC, and ICICI banks.');
            }

            result.accountInfo.bank = bankType + ' Bank';
            return result;
        }

        // HDFC BANK PARSER
        function parseHDFCBankStatement(text) {
            const transactions = [];
            let accountInfo = { bank: 'HDFC Bank' };
            let openingBalance = 0;

            // Extract account information
            const accMatch = text.match(/Account\s+No[:\s]*(\d{14,16})/i);
            if (accMatch) accountInfo.accountNumber = accMatch[1];

            const ifscMatch = text.match(/IFSC[:\s]*([A-Z]{4}\d{7})/i);
            if (ifscMatch) accountInfo.ifsc = ifscMatch[1];

            const nameMatch = text.match(/^(MR|MS|MRS|DR)\.?\s+([A-Z][A-Z\s]{5,40})/m);
            if (nameMatch) accountInfo.name = (nameMatch[1] + ' ' + nameMatch[2]).trim();

            const periodMatch = text.match(/(\d{2}[\/-]\d{2}[\/-]\d{2,4})\s+[Tt]o\s+(\d{2}[\/-]\d{2}[\/-]\d{2,4})/);
            if (periodMatch) accountInfo.period = `${periodMatch[1]} to ${periodMatch[2]}`;

            // Find opening balance
            const openMatch = text.match(/Opening\s+Balance[:\s]*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)/i);
            if (openMatch) {
                openingBalance = parseFloat(openMatch[1].replace(/,/g, ''));
            }

            // Parse transactions - HDFC uses line-by-line format
            const lines = text.split('\n');
            let prevBalance = openingBalance;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                // Match DD/MM/YY or DD/MM/YYYY or DD-MM-YYYY
                const dateMatch = line.match(/(\d{2}[\/\-]\d{2}[\/\-]\d{2,4})/);
                if (!dateMatch) continue;

                const date = dateMatch[1];

                // Extract amounts
                const amounts = line.match(/\d{1,3}(?:,\d{3})*(?:\.\d{2})?/g);
                if (!amounts || amounts.length < 1) continue;

                const parsedAmounts = amounts.map(a => parseFloat(a.replace(/,/g, '')));
                const balance = parsedAmounts[parsedAmounts.length - 1];

                if (Math.abs(balance - prevBalance) < 0.01) continue;

                const balanceChange = balance - prevBalance;
                const amount = Math.abs(balanceChange);
                const type = balanceChange > 0 ? 'Credit' : 'Debit';

                let description = line
                    .replace(/\d{2}[\/\-]\d{2}[\/\-]\d{2,4}/g, '')
                    .replace(/\d{1,3}(?:,\d{3})*(?:\.\d{2})?/g, '')
                    .replace(/\s{2,}/g, ' ')
                    .trim()
                    .substring(0, 150);

                if (description && amount >= 0.01) {
                    transactions.push({
                        date: date,
                        description: description,
                        type: type,
                        amount: amount,
                        balance: balance,
                        category: ''
                    });
                    prevBalance = balance;
                }
            }

            return {
                accountInfo: accountInfo,
                transactions: transactions,
                openingBalance: openingBalance
            };
        }

        // ICICI BANK PARSER
        function parseICICIBankStatement(text) {
            const transactions = [];
            let accountInfo = { bank: 'ICICI Bank' };
            let openingBalance = 0;

            // Extract account information
            const accMatch = text.match(/Account\s+No[:\s]*(\d{12,18})/i);
            if (accMatch) accountInfo.accountNumber = accMatch[1];

            const ifscMatch = text.match(/IFSC\s+Code[:\s]*([A-Z]{4}\d{7})/i);
            if (ifscMatch) accountInfo.ifsc = ifscMatch[1];

            const nameMatch = text.match(/^([A-Z][A-Z\s]{3,40})(?=\s*Joint|\s*Customer)/m);
            if (nameMatch) accountInfo.name = nameMatch[1].trim();

            const periodMatch = text.match(/From\s+(\d{2}-\d{2}-\d{4})\s+To\s+(\d{2}-\d{2}-\d{4})/i);
            if (periodMatch) accountInfo.period = `${periodMatch[1]} to ${periodMatch[2]}`;

            // Find opening balance
            const openMatch = text.match(/OPENING\s+BALANCE[\s\S]*?(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)/i);
            if (openMatch) {
                openingBalance = parseFloat(openMatch[1].replace(/,/g, ''));
            }

            // Parse transactions
            const lines = text.split('\n');
            let prevBalance = openingBalance;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                const dateMatch = line.match(/(\d{2}-\d{2}-\d{4})/);
                if (!dateMatch) continue;

                const date = dateMatch[1];

                const amounts = line.match(/\d{1,3}(?:,\d{3})*(?:\.\d{2})?/g);
                if (!amounts || amounts.length < 1) continue;

                const parsedAmounts = amounts.map(a => parseFloat(a.replace(/,/g, '')));
                const balance = parsedAmounts[parsedAmounts.length - 1];

                if (Math.abs(balance - prevBalance) < 0.01) continue;

                const balanceChange = balance - prevBalance;
                const amount = Math.abs(balanceChange);
                const type = balanceChange > 0 ? 'Credit' : 'Debit';

                let description = line
                    .replace(/\d{2}-\d{2}-\d{4}/g, '')
                    .replace(/\d{1,3}(?:,\d{3})*(?:\.\d{2})?/g, '')
                    .replace(/\s{2,}/g, ' ')
                    .replace(/^[\s\d]+/, '')
                    .trim()
                    .substring(0, 150);

                if (description && amount >= 0.01) {
                    transactions.push({
                        date: date,
                        description: description,
                        type: type,
                        amount: amount,
                        balance: balance,
                        category: ''
                    });
                    prevBalance = balance;
                }
            }

            return {
                accountInfo: accountInfo,
                transactions: transactions,
                openingBalance: openingBalance
            };
        }

        function parseAxisBankStatement(text) {
            const transactions = [];
            let accountInfo = {};
            let openingBalance = 0;
            let prevBalance = 0;

            // Extract account info
            const accMatch = text.match(/Account No[:\\s]*([\\d]{15,18})/i);
            if (accMatch) accountInfo.accountNumber = accMatch[1];

            const ifscMatch = text.match(/IFSC Code[:\\s]*([A-Z]{4}\\d{7})/i);
            if (ifscMatch) accountInfo.ifsc = ifscMatch[1];

            const periodMatch = text.match(/From[:\\s]*(\\d{2}[\\-\\/]\\d{2}[\\-\\/]\\d{4})\\s+To[:\\s]*(\\d{2}[\\-\\/]\\d{2}[\\-\\/]\\d{4})/i);
            if (periodMatch) accountInfo.period = `${periodMatch[1]} to ${periodMatch[2]}`;

            const nameMatch = text.match(/^([A-Z][A-Z\\s]{5,30})(?=\\s*Joint|\\s*NO\\s)/m);
            if (nameMatch) accountInfo.name = nameMatch[1].trim();

            // Find opening balance - it's the number right after "OPENING BALANCE" text
            const openMatch = text.match(/OPENING BALANCE[\\s\\S]*?(\\d+\\.\\d{2})/i);
            if (openMatch) {
                openingBalance = parseFloat(openMatch[1]);
                prevBalance = openingBalance;
            }

            // Parse all transactions
            // Pattern: DD-MM-YYYY followed by text then amounts and balance
            const dateRegex = /(\\d{2}-\\d{2}-\\d{4})/g;
            let match;
            
            while ((match = dateRegex.exec(text)) !== null) {
                const date = match[1];
                const startPos = match.index + date.length;
                
                // Get next 500 characters after the date
                const chunk = text.substring(startPos, startPos + 500);
                
                // Find the next date or end
                const nextDateMatch = chunk.match(/\\d{2}-\\d{2}-\\d{4}/);
                const chunkEnd = nextDateMatch ? nextDateMatch.index : chunk.length;
                const txnText = chunk.substring(0, chunkEnd);
                
                // Extract all decimal numbers (amounts)
                const amounts = txnText.match(/\\b\\d+\\.\\d{2}\\b/g);
                
                if (!amounts || amounts.length === 0) continue;
                
                // Last number is always the balance
                const balance = parseFloat(amounts[amounts.length - 1]);
                
                // Skip if balance didn't change
                if (balance === prevBalance) continue;
                
                // Calculate amount and type
                const balanceChange = balance - prevBalance;
                const amount = Math.abs(balanceChange);
                const type = balanceChange > 0 ? 'Credit' : 'Debit';
                
                // Extract description - remove dates and amounts
                let description = txnText
                    .replace(/\\d{2}-\\d{2}-\\d{4}/g, '')
                    .replace(/\\b\\d+\\.\\d{2}\\b/g, '')
                    .replace(/\\s{2,}/g, ' ')
                    .replace(/^[\\s\\d]+/, '')
                    .trim()
                    .substring(0, 150);
                
                if (description && amount >= 0.01) {
                    transactions.push({
                        date: date,
                        description: description,
                        type: type,
                        amount: amount,
                        balance: balance,
                        category: ''
                    });
                    
                    prevBalance = balance;
                }
            }

            return {
                accountInfo: accountInfo,
                transactions: transactions,
                openingBalance: openingBalance
            };
        }

        function categorizeTransaction(description) {
            const desc = description.toUpperCase();
            
            if (desc.includes('INT.PD') || desc.includes('INTEREST')) return 'Interest Income';
            if (desc.includes('SWIGGY') || desc.includes('ZOMATO') || desc.includes('HUNGERBOX') || 
                desc.includes('MDP COFFEE')) return 'Food & Dining';
            if (desc.includes('FLIPKART') || desc.includes('AMAZON') || desc.includes('MEESHO')) return 'Shopping';
            if (desc.includes('UBER') || desc.includes('IRCTC') || desc.includes('BUS')) return 'Transportation';
            if (desc.includes('HOSPITAL') || desc.includes('PHARMACY') || desc.includes('V CARE')) return 'Healthcare';
            if (desc.includes('WIPRO') || desc.includes('SALARY')) return 'Salary/Income';
            if (desc.includes('PPF') || desc.includes('IPPF') || desc.includes('MONEYLICIOUS') || desc.includes('DHAN')) return 'Investments';
            if (desc.includes('UPI/P2M') || desc.includes('UPI/P2A') || desc.includes('BHARATPE')) return 'UPI Payments';
            if (desc.includes('NEFT') || desc.includes('IMPS') || desc.includes('RTGS')) return 'Bank Transfers';
            if (desc.includes('ZEPTO') || desc.includes('BIGBASKET')) return 'Groceries';
            if (desc.includes('BOOKMYSHOW')) return 'Entertainment';
            if (desc.includes('AIRTEL') || desc.includes('JIO')) return 'Utilities';
            if (desc.includes('MAB') || desc.includes('CHARGE') || desc.includes('GST')) return 'Bank Charges';
            if (desc.includes('ACH-CR') || desc.includes('DIVIDEND') || desc.includes('VEDANTA') || desc.includes('HPCL')) return 'Dividend Income';
            if (desc.includes('AC XFR')) return 'Internal Transfer';
            
            return 'Others';
        }

        function calculateSummary(transactions, openingBalance) {
            let totalCredits = 0;
            let totalDebits = 0;
            
            transactions.forEach(txn => {
                if (txn.type === 'Credit') {
                    totalCredits += txn.amount;
                } else {
                    totalDebits += txn.amount;
                }
            });
            
            const closingBalance = transactions.length > 0 ? 
                transactions[transactions.length - 1].balance : openingBalance;
            
            return {
                openingBalance: openingBalance,
                closingBalance: closingBalance,
                totalCredits: totalCredits,
                totalDebits: totalDebits,
                netChange: closingBalance - openingBalance,
                transactionCount: transactions.length
            };
        }

        window.onload = function() {
            processPDF();
        };
    </script>
</body>
</html>
